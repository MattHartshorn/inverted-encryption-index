from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from . import keygen

BLOCK_SIZE = 16

def encrypt(plaintext, key, iv=None):
    """Encrypts the plaintext using CBC AES-256 encryption
    Arguments:
    plaintext -- The byte data that is to be encrypted
    key -- The encryption key in bytes
    iv -- The initialization vector, auto generated by default

    Returns:
    cyphertext -- The encrypted byte data
    iv -- The generated or input initialization vector
    """
    if (iv == None): iv = keygen.generate(128)

    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), default_backend())
    plaintext = addPadding(plaintext)
    cyphertext = cipher.encryptor().update(plaintext)
    return cyphertext, iv


def decrypt(cyphertext, key, iv):
    """Decrypts the cypher text using CBC AES-256 decryption
    Arguments:
    cyphertext -- The byte data that is to be decrypted
    key -- The encryption key in bytes
    iv -- The initialization vector used during encryption

    Returns:
    The decrypted byte data
    """
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), default_backend())
    plaintext = cipher.decryptor().update(cyphertext)
    return removePadding(plaintext)


def addPadding(data):
    """Adds padding bytes to the provided byte data to ensure the length of the
    data is divisible by the BLOCK_SIZE

    Arguments:
    data -- The byte data that requires padding

    Returns:
    The padded byte data
    """
    if (len(data) == 0):
        data = bytes([BLOCK_SIZE] * BLOCK_SIZE)
    elif (len(data) % BLOCK_SIZE != 0):
        padding = BLOCK_SIZE - (len(data) % BLOCK_SIZE)
        data = bytearray(data)
        data.extend(bytes([padding] * padding))
        data = bytes(data)
    
    return data

def removePadding(data):
    """Removes any padding used to encrypt the message

    Arguments:
    data -- The byte data that may or may not have padding
    
    Returns:
    The data without any padding
    """
    if (len(data) == 0 or len(data) % BLOCK_SIZE != 0):
        raise ValueError("Invalid message size")

    padding = data[-1]
    start = len(data) - padding
    for byte in data[start:]:
        if (byte != padding): return data

    return data[:start]
